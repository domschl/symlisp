#include <string.h>
#include <stdint.h>
#include <inttypes.h>
#include <stdlib.h>  // For malloc/free if needed later

#include "sl_strings.h"
#include "sl_core.h"
#include "sl_parse.h"
#include "sl_builtins.h"

// --- String Functions ---

// (string-length string) -> integer (number of Unicode code points)
static sl_object *sl_builtin_string_length(sl_object *args) {
    sl_object *arity_check = check_arity("string-length", args, 1);
    if (arity_check != SL_TRUE) return arity_check;

    sl_object *str_obj = sl_car(args);
    if (!sl_is_string(str_obj)) {
        return sl_make_errorf("Error (string-length): Expected a string, got %s.", sl_type_name(str_obj->type));
    }

    const char *utf8_str = sl_string_value(str_obj);
    if (!utf8_str) {  // Should not happen for valid string objects
        return sl_make_errorf("Error (string-length): String object has NULL value.");
    }

    size_t code_point_count = 0;
    const char *ptr = utf8_str;

    while (*ptr != '\0') {
        uint32_t code_point = decode_utf8(&ptr);     // decode_utf8 advances ptr
        if (code_point == 0 && *ptr == '\0') break;  // Normal EOF
        // We count even replacement characters as characters for length
        code_point_count++;
        if (code_point == UTF8_REPLACEMENT_CHAR && *ptr == '\0') break;  // EOF after error byte
    }

    // Return the count as a SymLisp number
    // For now, assume length fits in int64_t
    // TODO: Handle potential overflow into bignum if lengths can exceed INT64_MAX
    return sl_make_number_si((int64_t)code_point_count, 1);
}

// (string-ref string k) -> character at index k (0-based)
static sl_object *sl_builtin_string_ref(sl_object *args) {
    sl_object *arity_check = check_arity("string-ref", args, 2);
    if (arity_check != SL_TRUE) return arity_check;

    sl_object *str_obj = sl_car(args);
    sl_object *k_obj = sl_cadr(args);

    if (!sl_is_string(str_obj)) {
        return sl_make_errorf("Error (string-ref): Expected a string as the first argument, got %s.", sl_type_name(str_obj->type));
    }
    if (!sl_is_number(k_obj) || !sl_number_is_integer(k_obj)) {
        return sl_make_errorf("Error (string-ref): Expected an exact integer index as the second argument, got %s.", sl_type_name(k_obj->type));
    }

    const char *utf8_str = sl_string_value(str_obj);
    if (!utf8_str) {
        return sl_make_errorf("Error (string-ref): String object has NULL value.");
    }

    // Get the index k
    int64_t k;
    if (!get_number_as_int64(k_obj, &k, "string-ref")) {
        // Error message already generated by get_number_as_int64
        return SL_NIL;  // Indicate error
    }

    if (k < 0) {
        return sl_make_errorf("Error (string-ref): Index %" PRId64 " must be non-negative.", k);
    }

    // Iterate k code points into the string
    const char *ptr = utf8_str;
    uint32_t target_code_point = UTF8_REPLACEMENT_CHAR;  // Default if index is out of bounds
    bool found = false;
    int64_t current_index = 0;

    while (*ptr != '\0') {
        const char *start_of_char = ptr;
        uint32_t code_point = decode_utf8(&ptr);  // Advances ptr

        if (code_point == 0 && *ptr == '\0') break;  // Normal EOF

        if (current_index == k) {
            target_code_point = code_point;  // Could be UTF8_REPLACEMENT_CHAR if decode failed
            found = true;
            break;
        }

        current_index++;
        if (code_point == UTF8_REPLACEMENT_CHAR && *ptr == '\0') break;  // EOF after error byte
    }

    if (!found) {
        // Index k is out of bounds
        // Calculate actual length for a better error message
        size_t len = 0;
        const char *len_ptr = utf8_str;
        while (*len_ptr != '\0') {
            decode_utf8(&len_ptr);
            len++;
            if (*len_ptr == '\0' && len_ptr > utf8_str && *(len_ptr - 1) == '\0') break;  // Avoid infinite loop on decode error at end
        }
        return sl_make_errorf("Error (string-ref): Index %" PRId64 " out of bounds for string of length %zu.", k, len);
    }

    // Return the character object
    return sl_make_char(target_code_point);
}

// --- Initialization ---

void sl_strings_init(sl_object *global_env) {
    define_builtin(global_env, "string-length", sl_builtin_string_length);
    define_builtin(global_env, "string-ref", sl_builtin_string_ref);

    // Add other string functions here later
    // define_builtin(global_env, "string=?", sl_builtin_string_eq);
    // define_builtin(global_env, "substring", sl_builtin_substring);
    // ... etc ...
}